/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(vhdl_COCO_PARSER_H__)
#define vhdl_COCO_PARSER_H__

#include "../DesignFile.h"
#include <iostream>


#include "Scanner.h"

namespace vhdl {


class Errors {
public:
	int count;			// number of errors detected

	Errors();
	void SynErr(int line, int col, int n);
	void Error(int line, int col, const wchar_t *s);
	void Warning(int line, int col, const wchar_t *s);
	void Warning(const wchar_t *s);
	void Exception(const wchar_t *s);

}; // Errors

class Parser {
private:
	enum {
		_EOF=0,
		_basicIdentifier=1,
		_extendedIdentifier=2,
		_basedLiteral=3,
		_integerLiteral=4,
		_realLiteral=5,
		_stringLiteral=6,
		_bitStringLiteral=7,
		_apostrophe=8,
		_characterLiteral=9,
		_abs=10,
		_access=11,
		_after=12,
		_alias=13,
		_all=14,
		_and=15,
		_architecture=16,
		_array=17,
		_assert=18,
		_attribute=19,
		_begin=20,
		_block=21,
		_body=22,
		_buffer=23,
		_bus=24,
		_case=25,
		_component=26,
		_configuration=27,
		_constant=28,
		_disconnect=29,
		_downto=30,
		_else=31,
		_elsif=32,
		_end=33,
		_entity=34,
		_exit=35,
		_file=36,
		_for=37,
		_function=38,
		_generate=39,
		_generic=40,
		_group=41,
		_guarded=42,
		_if=43,
		_impure=44,
		_in=45,
		_inertial=46,
		_inout=47,
		_is=48,
		_label=49,
		_library=50,
		_linkage=51,
		_literal=52,
		_loop=53,
		_map=54,
		_mod=55,
		_nand=56,
		_new=57,
		_next=58,
		_nor=59,
		_not=60,
		_null=61,
		_of=62,
		_on=63,
		_open=64,
		_or=65,
		_others=66,
		_outToken=67,
		_package=68,
		_port=69,
		_postponed=70,
		_procedure=71,
		_process=72,
		_protected=73,
		_pure=74,
		_range=75,
		_record=76,
		_register=77,
		_reject=78,
		_rem=79,
		_report=80,
		_return=81,
		_rol=82,
		_ror=83,
		_select=84,
		_severity=85,
		_shared=86,
		_signal=87,
		_sla=88,
		_sll=89,
		_sra=90,
		_srl=91,
		_subtype=92,
		_then=93,
		_to=94,
		_transport=95,
		_type=96,
		_unaffected=97,
		_units=98,
		_until=99,
		_use=100,
		_variable=101,
		_wait=102,
		_when=103,
		_while=104,
		_with=105,
		_xnor=106,
		_xor=107,
		_doublestar=108,
		_leq=109,
		_geq=110,
		_arrow=111,
		_neq=112,
		_varAssign=113,
		_box=114,
		_semicolon=115,
		_comma=116,
		_ampersand=117,
		_lparen=118,
		_rparen=119,
		_lbracket=120,
		_rbracket=121,
		_colon=122,
		_mul=123,
		_div=124,
		_plus=125,
		_minus=126,
		_lt=127,
		_gt=128,
		_eq=129,
		_bar=130,
		_dot=131
	};
	int maxT;

	Token *dummyToken;
	int errDist;
	int minErrDist;

	void SynErr(int n);
	void Get();
	void Expect(int n);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);

public:
	Scanner *scanner;
	Errors  *errors;

	Token *t;			// last recognized token
	Token *la;			// lookahead token

typedef std::list<std::string> StrList;
         /** 
         * Returns the current token as std::string
         * 
         * @return Current token
         */           
         std::string CurrentToken() const {
             char * cstr = coco_string_create_char(t->val);
             std::string str(cstr);
             coco_string_delete(cstr);
             return str;
         }
         void Print(std::string const & str) {
              std::cout << str << std::endl;
         }      
    void Parse(DesignFile * df) {
         mpDf = df;
         if(mpDf) {
             Parse();
         }
    }
         
    DesignFile * mpDf;
	
	//group_template = group Identifier is lparen ...
	//GroupDeclaration = group Identifier colon ...
	//la == group
	bool isGroupTemplate() {
		if (la->kind!=_group) return false;
		scanner->ResetPeek();
		scanner->Peek();
		Token * next = scanner->Peek();
		return next->kind==_is;
	}

	//AttributeDeclaration = attribute Identifier colon TypeMark semicolon 
	//AttributeSpecification = attribute Identifier of EntityNameList colon EntityClass is Expression semicolon 
	//la == attribute
	bool isAttributeDeclaration() {
		if (la->kind!=_attribute) return false;
		scanner->ResetPeek();
		scanner->Peek();
		Token * next=scanner->Peek();
		return next->kind==_colon;
	}

	//PhysicalTypeDefinition = range Range units ...
	//IntegerOrFloatingPointTypeDefinition = range Range semicolon
	//la == range
	bool isPhysicalType() {
		if (la->kind!=_range) return false;
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_units && next->kind!=_semicolon && next->kind!=_EOF);
		return next->kind==_units;
	}

	//constrained array = lparen IndexSubtypeDefinition { comma IndexSubtypeDefinition } rparen of SubtypeIndication
	//IndexSubtypeDefinition = TypeMark range box
	//IndexConstraint = lparen DiscreteRange { comma DiscreteRange } rparen
	//la==lparen
	bool isIndexSubtypeDefinition() {
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_box && next->kind!=_semicolon && next->kind!=_rparen && next->kind!=_lparen && next->kind!=_EOF);
		return next->kind==_box;
	}
	
	//ProcedureCallStatement = SelectedName [lparen AssociationList rparen] semicolon
	//SignalOrVariableAssignmentStatement = Target (varAssign | leq) ....
	//Target = Name | Aggregate
	bool isAssignmentStatement() {
		scanner->ResetPeek();
		Token * next;
		int count=0;
		do {
			next = scanner->Peek();
			if (next->kind==_lparen) count++;
			else if (next->kind==_rparen) count--;
		}while (next->kind!=_varAssign && next->kind!=_leq && next->kind!=_semicolon && next->kind!=_EOF);
		return (next->kind==_varAssign || next->kind==_leq) && count==0;
	}
	
	//ConcurrentSignalAssignmentStatement = (Target leq | with) ....
	//ConcurrentProcedureCallStatement = SelectedName [lparen AssociationList rparen] semicolon
	bool isConcurrentSignalAssignmentStatement() {
		if (la->kind==_with) return true;
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_leq && next->kind!=_semicolon && next->kind!=_EOF);
		return next->kind==_leq;
	}

	//For those parameters with modes, the only modes that are allowed for formal parameters of a procedure are
	//in, inout, and out. If the mode is in and no object class is explicitly specified, constant is assumed. If the
	//mode is inout or out, and no object class is explicitly specified, variable is assumed.
	//
	//InterfaceConstantDeclaration = [constant] IdentifierList colon [in] SubtypeIndication [varAssign Expression] 
	bool isInterfaceConstantDeclaration() {
		if (la->kind==_constant) return true;
		else if (la->kind==_variable || la->kind==_signal || la->kind==_file) return false;
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_varAssign && next->kind!=_semicolon && next->kind!=_in && next->kind!=_EOF);
		return next->kind==_in;
	}
	
	//InterfaceVariableDeclaration = [variable] IdentifierList colon [InterfaceMode] SubtypeIndication [varAssign Expression]
	bool isInterfaceVariableDeclaration() {
		if (la->kind==_variable) return true;
		else if (la->kind==_constant || la->kind==_signal || la->kind==_file) return false;
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_varAssign && next->kind!=_semicolon && next->kind!=_in && next->kind!=_inout && next->kind!=_outToken && next->kind!=_EOF);
		return next->kind==_inout || next->kind==_outToken;
	}

	//search fo TO or downto in Range: Expression Direction Expression
	//Choice = DiscreteRange
	//	| SimpleExpression
	//	| others		
	//Choices = Choice { bar Choice }
	//CaseStatement = .... { when Choices arrow SequentialStatementList } ...
	//ElementAssociation = [Choices arrow] Expression 
	//SelectedWaveform = Waveform when Choices
	//SelectedSignalAssignment = ... SelectedWaveform { comma SelectedWaveform } semicolon
	bool isRangeInChoice() {
		if (la->kind==_others) return false;
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_bar && next->kind!=_arrow && next->kind!=_comma && next->kind!=_semicolon && next->kind!=_to && next->kind!=_downto && next->kind!=_EOF);
		return next->kind==_to || next->kind==_downto;
	}
	
	//search fo TO or downto in Range = Expression Direction Expression
	//BlockConfigurationIndex= 
	//	  DiscreteRange
	//	  | Expression
	//BlockSpecification=
	//	Identifier [lparen BlockConfigurationIndex rparen]
	//	| SelectedName
	//BlockConfiguration =
	//		for BlockSpecification
	//		{ UseClause }
	//		{
	//			blockConfiguration
	//			| ComponentConfiguration
	//		}
	//		end for semicolon
	bool isDiscreteRangeInBlockConfigurationIndex() {
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_use && next->kind!=_for && next->kind!=_end && next->kind!=_semicolon && next->kind!=_to && next->kind!=_downto && next->kind!=_EOF);
		return next->kind==_to || next->kind==_downto;
	}
	
	bool isArchitectureStatementWithLabel() {
		if (la->kind==_component || la->kind==_entity || la->kind==_configuration  || la->kind==_block || la->kind==_for || la->kind==_if) return true;
		else if (la->kind==_postponed || la->kind==_process || la->kind==_assert || la->kind==_file || isConcurrentSignalAssignmentStatement()) return false;
		//distinguish between ComponentInstantiationStatement and ConcurrentProcedureCallStatement
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_generic && next->kind!=_port && next->kind!=_semicolon && next->kind!=_EOF);
		return next->kind==_generic || next->kind==_port;
	}

	//SlicePart = lparen DiscreteRange rparen.
	//name_indexed_part = lparen Expression { comma Expression }
	//AssociationListPart = lparen AssociationList rparen
	bool isSlicePart() {
		if (la->kind!=_lparen) return false;
		scanner->ResetPeek();
		Token * next;
		int count=1;//count lparen
		do {
			next = scanner->Peek();
			if (next->kind==_lparen) count++;
			else if (next->kind==_rparen) count--;
		}while (count!=0 && next->kind!=_bar && next->kind!=_arrow && next->kind!=_semicolon && next->kind!=_to && next->kind!=_downto && next->kind!=_EOF);
		return (next->kind==_to || next->kind==_downto) && count<=1;
	}

	//Choice =
	//		IF(isRangeInChoice()) DiscreteRange
	//		| SimpleExpression
	//		| others
	//Choices = Choice { bar Choice }.
	//ElementAssociation = [IF(isChoiceInElementAssociation()) Choices arrow] Expression.
	//Aggregate = lparen  ElementAssociation { comma ElementAssociation } rparen .
	bool isChoiceInElementAssociation() {
		scanner->ResetPeek();
		Token * next=la;
		int count=1;//count lparen
		do {
			if (next->kind==_lparen) count++;
			else if (next->kind==_rparen) count--;
			next = scanner->Peek();
		}while (count!=0 && next->kind!=_comma && next->kind!=_arrow && next->kind!=_semicolon && next->kind!=_others && next->kind!=_EOF);
		return (next->kind==_arrow || next->kind==_others) && count<=1;
	}

	//FormalPart = Name .
	//ActualPart =  Expression | open .
	//AssociationElement = [If(isFormalPartInAssociationElement()) FormalPart arrow] ActualPart .
	//AssociationList = AssociationElement { comma AssociationElement }.
	//lparen AssociationList rparen
	bool isFormalPartInAssociationElement() {
		if (la->kind!=_basicIdentifier && la->kind!=_extendedIdentifier) return false;
		scanner->ResetPeek();
		Token * next;
		int count=0;
		do {
			next = scanner->Peek();
			if (next->kind==_lparen) count++;
			else if (next->kind==_rparen) count--;
		}while (count>=0 && next->kind!=_comma && next->kind!=_others && next->kind!=_arrow && next->kind!=_semicolon && next->kind!=_open && next->kind!=_EOF);
		return next->kind==_arrow && count==0;
	}

	//Range = SimpleExpression Direction SimpleExpression
	//		  | Name
	bool isNotNameInRange() {
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_units && next->kind!=_varAssign && next->kind!=_generate && next->kind!=_loop && next->kind!=_is && next->kind!=_open && next->kind!=_semicolon && next->kind!=_to && next->kind!=_downto && next->kind!=_EOF);
		return next->kind==_to || next->kind==_downto;
	}

	//DiscreteRange = SubtypeIndication
	//				  | Range.
	bool isSubtypeIndicationInDiscreteRange() {
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_range && next->kind!=_apostrophe && next->kind!=_to && next->kind!=_downto && next->kind!=_lparen && next->kind!=_semicolon && next->kind!=_EOF);
		return next->kind==_range;
	}

	bool isQualifiedExpression() {
		if (la->kind!=_basicIdentifier && la->kind!=_extendedIdentifier) return false;
		scanner->ResetPeek();
		Token * next;
		//match SelectedName
		do {
			next = scanner->Peek();
		}while (next->kind==_basicIdentifier || next->kind==_extendedIdentifier || next->kind==_dot && next->kind!=_EOF);
		return next->kind==_apostrophe && scanner->Peek()->kind==_lparen;
	}

	bool isComponentConfigurationInBlockConfiguration() {
		scanner->ResetPeek();
		Token * next;
		do {
			next = scanner->Peek();
		}while (next->kind!=_colon && next->kind!=_lparen && next->kind!=_for && next->kind!=_EOF);
		return next->kind==_colon;
	}



	Parser(Scanner *scanner);
	~Parser();
	void SemErr(const wchar_t* msg);

	void VHDL();
	void DesignUnit();
	void LibraryClause();
	void UseClause();
	void LibraryUnit();
	void EntityDeclaration();
	void ArchitectureBody();
	void PackageBody();
	void PackageDeclaration();
	void ConfigurationDeclaration();
	void NamedIdentifierList(StrList & l);
	void GenericClause();
	void GenericInterfaceList();
	void InterfaceConstantDeclaration();
	void PortClause();
	void PortInterfaceList();
	void InterfaceSignalDeclarationProcedure();
	void NamedIdentifier(std::string & s);
	void EntityDeclarativeItem();
	void LabelColon();
	void ConcurrentAssertionStatement();
	void ConcurrentProcedureCallStatement();
	void ProcessStatement();
	void Identifier();
	void SubprogramDeclarationOrBody();
	void TypeDeclaration();
	void SubtypeDeclaration();
	void ConstantDeclaration();
	void SignalDeclaration();
	void VariableDeclaration();
	void FileDeclaration();
	void AliasDeclaration();
	void AttributeDeclaration();
	void AttributeSpecification();
	void DisconnectionSpecification();
	void GroupTemplateDeclaration();
	void GroupDeclaration();
	void NamedSelectedName(std::string & n);
	void BlockDeclarativeItem();
	void ArchitectureStatementList();
	void ConfigurationDeclarativeItem();
	void SelectedName();
	void BlockConfiguration();
	void BlockConfigurationIndex();
	void DiscreteRange();
	void Expression();
	void BlockSpecification();
	void ComponentConfiguration();
	void ComponentSpecification();
	void BindingIndication();
	void PackageDeclarativeItem();
	void SubprogramDeclaration();
	void ComponentDeclaration();
	void PackageBodyDeclarativeItem();
	void Designator();
	void SubprogramSpecification();
	void ParameterInterfaceListProcedure();
	void ParameterInterfaceListFunction();
	void TypeMark();
	void SubprogramBody();
	void SubprogramDeclarativeItem();
	void SequentialStatementList();
	void TypeDefinition();
	void EnumerationTypeDefinition();
	void PhysicalTypeDefinition();
	void IntegerOrFloatingPointTypeDefinition();
	void ArrayTypeDefinition();
	void RecordTypeDefinition();
	void AccessTypeDefinition();
	void FileTypeDefinition();
	void ProtectedTypeBody();
	void ProtectedTypeDeclaration();
	void IdentifierList();
	void SubtypeIndication();
	void AliasDesignator();
	void Name();
	void Signature();
	void EntityNameList();
	void EntityClass();
	void EntityDesignator();
	void ConfigurationSpecification();
	void InstantiationList();
	void EntityAspect();
	void GenericMapAspect();
	void PortMapAspect();
	void SelectedNameList();
	void EntityClassEntry();
	void GroupConstituentList();
	void GroupConstituent();
	void NamedSelectedNameList(StrList & l);
	void EnumerationLiteral();
	void Range();
	void PhysicalLiteral();
	void IndexSubtypeDefinition();
	void IndexConstraint();
	void ProtectedTypeDeclarativeItem();
	void ProtectedTypeBodyDeclarativeItem();
	void Constraint();
	void Direction();
	void RangeConstraint();
	void SimpleExpression();
	void ArchitectureStatement();
	void ArchitectureStatementWithLabel();
	void ArchitectureStatementOptionalLabel();
	void ComponentInstantiationStatement();
	void BlockStatement();
	void GenerateStatement();
	void ConcurrentSignalAssignmentStatement();
	void AssociationList();
	void NameList();
	void ProcessDeclarativeItem();
	void Condition();
	void ConditionalSignalAssignment();
	void SelectedSignalAssignment();
	void Target();
	void DelayMechanism();
	void ConditionalWaveforms();
	void Waveform();
	void SelectedWaveform();
	void Choices();
	void Aggregate();
	void ForGenerateStatement();
	void IfGenerateStatement();
	void GenerateStatementBody();
	void SequentialStatement();
	void WaitStatement();
	void AssertionStatement();
	void ReportStatement();
	void IfStatement();
	void CaseStatement();
	void LoopStatement();
	void NextStatement();
	void ExitStatement();
	void ReturnStatement();
	void NullStatement();
	void SignalOrVariableAssignmentStatement();
	void ProcedureCallStatement();
	void SignalAssignmentStatement();
	void VariableAssignmentStatement();
	void WaveformElement();
	void IterationScheme();
	void InterfaceElementProcedure();
	void InterfaceVariableDeclaration();
	void InterfaceFileDeclaration();
	void InterfaceElementFunction();
	void InterfaceSignalDeclarationFunction();
	void InterfaceMode();
	void AssociationElement();
	void FormalPart();
	void ActualPart();
	void Relation();
	void LogicalOperator();
	void ShiftExpression();
	void RelationalOperator();
	void ShiftOperator();
	void Sign();
	void Term();
	void AddingOperator();
	void MultiplyingOperator();
	void Factor();
	void Primary();
	void QualifiedExpression();
	void Literal();
	void Allocator();
	void Prefix();
	void SelectedPart();
	void NamedPrefix(std::string & s);
	void NamedSelectedPart(std::string & n);
	void NamePart();
	void AttributePart();
	void SlicePart();
	void AssociationListPart();
	void ElementAssociation();
	void Choice();

	void Parse();

}; // end Parser

} // namespace


#endif

