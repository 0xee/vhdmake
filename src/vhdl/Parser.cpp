/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#include <wchar.h>
#include "Parser.h"
#include "Scanner.h"


namespace vhdl {


void Parser::SynErr(int n) {
	if (errDist >= minErrDist) errors->SynErr(la->line, la->col, n);
	errDist = 0;
}

void Parser::SemErr(const wchar_t* msg) {
	if (errDist >= minErrDist) errors->Error(t->line, t->col, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		t = la;
		la = scanner->Scan();
		if (la->kind <= maxT) { ++errDist; break; }

		if (dummyToken != t) {
			dummyToken->kind = t->kind;
			dummyToken->pos = t->pos;
			dummyToken->col = t->col;
			dummyToken->line = t->line;
			dummyToken->next = NULL;
			coco_string_delete(dummyToken->val);
			dummyToken->val = coco_string_create(t->val);
			t = dummyToken;
		}
		la = t;
	}
}

void Parser::Expect(int n) {
	if (la->kind==n) Get(); else { SynErr(n); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::VHDL() {
		DesignUnit();
		while (StartOf(1)) {
			DesignUnit();
		}
}

void Parser::DesignUnit() {
		while (la->kind == _library || la->kind == _use) {
			if (la->kind == _library) {
				LibraryClause();
			} else {
				UseClause();
			}
		}
		LibraryUnit();
}

void Parser::LibraryClause() {
		StrList libs; 
		Expect(_library);
		NamedIdentifierList(libs);
		Expect(_semicolon);
}

void Parser::UseClause() {
		StrList selNames; 
		Expect(_use);
		NamedSelectedNameList(selNames);
		Expect(_semicolon);
		for(auto name: selNames) mpDf->AddPkgUse(name); 
}

void Parser::LibraryUnit() {
		if (la->kind == _entity) {
			EntityDeclaration();
		} else if (la->kind == _architecture) {
			ArchitectureBody();
		} else if (la->kind==_package && scanner->Peek()->kind==_body) {
			PackageBody();
		} else if (la->kind == _package) {
			PackageDeclaration();
		} else if (la->kind == _configuration) {
			ConfigurationDeclaration();
		} else SynErr(133);
}

void Parser::EntityDeclaration() {
		std::string entity; 
		Expect(_entity);
		NamedIdentifier(entity);
		Expect(_is);
		mpDf->AddEntityDeclaration(entity); 
		if (la->kind == _generic) {
			GenericClause();
		}
		if (la->kind == _port) {
			PortClause();
		}
		while (StartOf(2)) {
			EntityDeclarativeItem();
		}
		if (la->kind == _begin) {
			Get();
			while (StartOf(3)) {
				if (scanner->Peek()->kind==_colon) {
					LabelColon();
				}
				if (la->kind == _postponed) {
					Get();
				}
				if (la->kind == _assert) {
					ConcurrentAssertionStatement();
				} else if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
					ConcurrentProcedureCallStatement();
				} else if (la->kind == _process) {
					ProcessStatement();
				} else SynErr(134);
			}
		}
		Expect(_end);
		if (la->kind == _entity) {
			Get();
		}
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::ArchitectureBody() {
		std::string arch, ent; 
		Expect(_architecture);
		NamedIdentifier(arch);
		Expect(_of);
		NamedSelectedName(ent);
		Expect(_is);
		mpDf->AddArchitectureDeclaration(ent, arch); 
		while (StartOf(4)) {
			BlockDeclarativeItem();
		}
		Expect(_begin);
		ArchitectureStatementList();
		Expect(_end);
		if (la->kind == _architecture) {
			Get();
		}
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::PackageBody() {
		Expect(_package);
		Expect(_body);
		Identifier();
		Expect(_is);
		while (StartOf(5)) {
			PackageBodyDeclarativeItem();
		}
		Expect(_end);
		if (la->kind == _package) {
			Get();
			Expect(_body);
		}
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::PackageDeclaration() {
		std::string pkg; 
		Expect(_package);
		NamedIdentifier(pkg);
		Expect(_is);
		mpDf->AddPkgDeclaration(pkg); 
		while (StartOf(6)) {
			PackageDeclarativeItem();
		}
		Expect(_end);
		if (la->kind == _package) {
			Get();
		}
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::ConfigurationDeclaration() {
		Expect(_configuration);
		Identifier();
		Expect(_of);
		SelectedName();
		Expect(_is);
		while (la->kind == _attribute || la->kind == _group || la->kind == _use) {
			ConfigurationDeclarativeItem();
		}
		BlockConfiguration();
		Expect(_end);
		if (la->kind == _configuration) {
			Get();
		}
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::NamedIdentifierList(StrList & l) {
		Identifier();
		l = StrList(); l.push_back(CurrentToken()); 
		while (la->kind == _comma) {
			Get();
			Identifier();
			l.push_back(CurrentToken()); 
		}
}

void Parser::GenericClause() {
		Expect(_generic);
		Expect(_lparen);
		GenericInterfaceList();
		Expect(_rparen);
		Expect(_semicolon);
}

void Parser::GenericInterfaceList() {
		InterfaceConstantDeclaration();
		while (la->kind == _semicolon) {
			Get();
			InterfaceConstantDeclaration();
		}
}

void Parser::InterfaceConstantDeclaration() {
		if (la->kind == _constant) {
			Get();
		}
		IdentifierList();
		Expect(_colon);
		if (la->kind == _in) {
			Get();
		}
		SubtypeIndication();
		if (la->kind == _varAssign) {
			Get();
			Expression();
		}
}

void Parser::PortClause() {
		Expect(_port);
		Expect(_lparen);
		PortInterfaceList();
		Expect(_rparen);
		Expect(_semicolon);
}

void Parser::PortInterfaceList() {
		InterfaceSignalDeclarationProcedure();
		while (la->kind == _semicolon) {
			Get();
			InterfaceSignalDeclarationProcedure();
		}
}

void Parser::InterfaceSignalDeclarationProcedure() {
		if (la->kind == _signal) {
			Get();
		}
		IdentifierList();
		Expect(_colon);
		if (StartOf(7)) {
			InterfaceMode();
		}
		SubtypeIndication();
		if (la->kind == _bus) {
			Get();
		}
		if (la->kind == _varAssign) {
			Get();
			Expression();
		}
}

void Parser::NamedIdentifier(std::string & s) {
		if (la->kind == _basicIdentifier) {
			Get();
		} else if (la->kind == _extendedIdentifier) {
			Get();
		} else SynErr(135);
		s = CurrentToken(); 
}

void Parser::EntityDeclarativeItem() {
		while (!(StartOf(8))) {SynErr(136); Get();}
		if (StartOf(9)) {
			SubprogramDeclarationOrBody();
		} else if (la->kind == _type) {
			TypeDeclaration();
		} else if (la->kind == _subtype) {
			SubtypeDeclaration();
		} else if (la->kind == _constant) {
			ConstantDeclaration();
		} else if (la->kind == _signal) {
			SignalDeclaration();
		} else if (la->kind == _shared || la->kind == _variable) {
			VariableDeclaration();
		} else if (la->kind == _file) {
			FileDeclaration();
		} else if (la->kind == _alias) {
			AliasDeclaration();
		} else if (isAttributeDeclaration()) {
			AttributeDeclaration();
		} else if (la->kind == _attribute) {
			AttributeSpecification();
		} else if (la->kind == _disconnect) {
			DisconnectionSpecification();
		} else if (la->kind == _use) {
			UseClause();
		} else if (isGroupTemplate()) {
			GroupTemplateDeclaration();
		} else if (la->kind == _group) {
			GroupDeclaration();
		} else SynErr(137);
}

void Parser::LabelColon() {
		Identifier();
		Expect(_colon);
}

void Parser::ConcurrentAssertionStatement() {
		Expect(_assert);
		Condition();
		if (la->kind == _report) {
			Get();
			Expression();
		}
		if (la->kind == _severity) {
			Get();
			Expression();
		}
		Expect(_semicolon);
}

void Parser::ConcurrentProcedureCallStatement() {
		SelectedName();
		if (la->kind == _lparen) {
			Get();
			AssociationList();
			Expect(_rparen);
		}
		Expect(_semicolon);
}

void Parser::ProcessStatement() {
		Expect(_process);
		if (la->kind == _lparen) {
			Get();
			if (StartOf(10)) {
				if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
					NameList();
				} else {
					Get();
				}
			}
			Expect(_rparen);
		}
		if (la->kind == _is) {
			Get();
		}
		while (StartOf(11)) {
			ProcessDeclarativeItem();
		}
		Expect(_begin);
		SequentialStatementList();
		Expect(_end);
		if (la->kind == _postponed) {
			Get();
		}
		Expect(_process);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::Identifier() {
		if (la->kind == _basicIdentifier) {
			Get();
		} else if (la->kind == _extendedIdentifier) {
			Get();
		} else SynErr(138);
}

void Parser::SubprogramDeclarationOrBody() {
		SubprogramSpecification();
		if (la->kind == _is) {
			SubprogramBody();
		}
		Expect(_semicolon);
}

void Parser::TypeDeclaration() {
		Expect(_type);
		Identifier();
		if (la->kind == _is) {
			Get();
			TypeDefinition();
			Expect(_semicolon);
		} else if (la->kind == _semicolon) {
			Get();
		} else SynErr(139);
}

void Parser::SubtypeDeclaration() {
		Expect(_subtype);
		Identifier();
		Expect(_is);
		SubtypeIndication();
		Expect(_semicolon);
}

void Parser::ConstantDeclaration() {
		Expect(_constant);
		IdentifierList();
		Expect(_colon);
		SubtypeIndication();
		if (la->kind == _varAssign) {
			Get();
			Expression();
		}
		Expect(_semicolon);
}

void Parser::SignalDeclaration() {
		Expect(_signal);
		IdentifierList();
		Expect(_colon);
		SubtypeIndication();
		if (la->kind == _bus || la->kind == _register) {
			if (la->kind == _register) {
				Get();
			} else {
				Get();
			}
		}
		if (la->kind == _varAssign) {
			Get();
			Expression();
		}
		Expect(_semicolon);
}

void Parser::VariableDeclaration() {
		if (la->kind == _shared) {
			Get();
		}
		Expect(_variable);
		IdentifierList();
		Expect(_colon);
		SubtypeIndication();
		if (la->kind == _varAssign) {
			Get();
			Expression();
		}
		Expect(_semicolon);
}

void Parser::FileDeclaration() {
		Expect(_file);
		IdentifierList();
		Expect(_colon);
		SubtypeIndication();
		if (la->kind == _is || la->kind == _open) {
			if (la->kind == _open) {
				Get();
				Expression();
			}
			Expect(_is);
			Expression();
		}
		Expect(_semicolon);
}

void Parser::AliasDeclaration() {
		Expect(_alias);
		AliasDesignator();
		if (la->kind == _colon) {
			Get();
			SubtypeIndication();
		}
		Expect(_is);
		Name();
		if (la->kind == _lbracket) {
			Signature();
		}
		Expect(_semicolon);
}

void Parser::AttributeDeclaration() {
		Expect(_attribute);
		Identifier();
		Expect(_colon);
		TypeMark();
		Expect(_semicolon);
}

void Parser::AttributeSpecification() {
		Expect(_attribute);
		Identifier();
		Expect(_of);
		EntityNameList();
		Expect(_colon);
		EntityClass();
		Expect(_is);
		Expression();
		Expect(_semicolon);
}

void Parser::DisconnectionSpecification() {
		Expect(_disconnect);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			SelectedNameList();
		} else if (la->kind == _others) {
			Get();
		} else if (la->kind == _all) {
			Get();
		} else SynErr(140);
		Expect(_colon);
		TypeMark();
		Expect(_after);
		Expression();
		Expect(_semicolon);
}

void Parser::GroupTemplateDeclaration() {
		Expect(_group);
		Identifier();
		Expect(_is);
		Expect(_lparen);
		EntityClassEntry();
		while (la->kind == _comma) {
			Get();
			EntityClassEntry();
		}
		Expect(_rparen);
		Expect(_semicolon);
}

void Parser::GroupDeclaration() {
		Expect(_group);
		Identifier();
		Expect(_colon);
		SelectedName();
		Expect(_lparen);
		GroupConstituentList();
		Expect(_rparen);
		Expect(_semicolon);
}

void Parser::NamedSelectedName(std::string & n) {
		std::string s; 
		NamedPrefix(n);
		while (la->kind == _dot) {
			NamedSelectedPart(s);
			n+= s; 
		}
}

void Parser::BlockDeclarativeItem() {
		while (!(StartOf(12))) {SynErr(141); Get();}
		if (StartOf(9)) {
			SubprogramDeclarationOrBody();
		} else if (la->kind == _type) {
			TypeDeclaration();
		} else if (la->kind == _subtype) {
			SubtypeDeclaration();
		} else if (la->kind == _constant) {
			ConstantDeclaration();
		} else if (la->kind == _signal) {
			SignalDeclaration();
		} else if (la->kind == _shared || la->kind == _variable) {
			VariableDeclaration();
		} else if (la->kind == _file) {
			FileDeclaration();
		} else if (la->kind == _alias) {
			AliasDeclaration();
		} else if (la->kind == _component) {
			ComponentDeclaration();
		} else if (isAttributeDeclaration()) {
			AttributeDeclaration();
		} else if (la->kind == _attribute) {
			AttributeSpecification();
		} else if (la->kind == _for) {
			ConfigurationSpecification();
		} else if (la->kind == _disconnect) {
			DisconnectionSpecification();
		} else if (la->kind == _use) {
			UseClause();
		} else if (isGroupTemplate()) {
			GroupTemplateDeclaration();
		} else if (la->kind == _group) {
			GroupDeclaration();
		} else SynErr(142);
}

void Parser::ArchitectureStatementList() {
		while (StartOf(13)) {
			ArchitectureStatement();
		}
}

void Parser::ConfigurationDeclarativeItem() {
		while (!(StartOf(14))) {SynErr(143); Get();}
		if (la->kind == _use) {
			UseClause();
		} else if (la->kind == _group) {
			GroupDeclaration();
		} else if (la->kind == _attribute) {
			AttributeSpecification();
		} else SynErr(144);
}

void Parser::SelectedName() {
		Prefix();
		while (la->kind == _dot) {
			SelectedPart();
		}
}

void Parser::BlockConfiguration() {
		Expect(_for);
		BlockSpecification();
		while (la->kind == _use) {
			UseClause();
		}
		while (la->kind == _for) {
			if (isComponentConfigurationInBlockConfiguration()) {
				ComponentConfiguration();
			} else {
				BlockConfiguration();
			}
		}
		Expect(_end);
		Expect(_for);
		Expect(_semicolon);
}

void Parser::BlockConfigurationIndex() {
		if (isDiscreteRangeInBlockConfigurationIndex()) {
			DiscreteRange();
		} else if (StartOf(15)) {
			Expression();
		} else SynErr(145);
}

void Parser::DiscreteRange() {
		if (isSubtypeIndicationInDiscreteRange()) {
			SubtypeIndication();
		} else if (StartOf(15)) {
			Range();
		} else SynErr(146);
}

void Parser::Expression() {
		Relation();
		while (StartOf(16)) {
			LogicalOperator();
			Relation();
		}
}

void Parser::BlockSpecification() {
		if (scanner->Peek()->kind==_lparen) {
			Identifier();
			if (la->kind == _lparen) {
				Get();
				BlockConfigurationIndex();
				Expect(_rparen);
			}
		} else if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			SelectedName();
		} else SynErr(147);
}

void Parser::ComponentConfiguration() {
		Expect(_for);
		ComponentSpecification();
		if (StartOf(17)) {
			BindingIndication();
			Expect(_semicolon);
		}
		if (la->kind == _for) {
			BlockConfiguration();
		}
		Expect(_end);
		Expect(_for);
		Expect(_semicolon);
}

void Parser::ComponentSpecification() {
		InstantiationList();
		Expect(_colon);
		SelectedName();
}

void Parser::BindingIndication() {
		if (la->kind == _use) {
			Get();
			EntityAspect();
		}
		if (la->kind == _generic) {
			GenericMapAspect();
		}
		if (la->kind == _port) {
			PortMapAspect();
		}
}

void Parser::PackageDeclarativeItem() {
		while (!(StartOf(18))) {SynErr(148); Get();}
		if (StartOf(9)) {
			SubprogramDeclaration();
		} else if (la->kind == _type) {
			TypeDeclaration();
		} else if (la->kind == _subtype) {
			SubtypeDeclaration();
		} else if (la->kind == _constant) {
			ConstantDeclaration();
		} else if (la->kind == _signal) {
			SignalDeclaration();
		} else if (la->kind == _shared || la->kind == _variable) {
			VariableDeclaration();
		} else if (la->kind == _file) {
			FileDeclaration();
		} else if (la->kind == _alias) {
			AliasDeclaration();
		} else if (la->kind == _component) {
			ComponentDeclaration();
		} else if (isAttributeDeclaration()) {
			AttributeDeclaration();
		} else if (la->kind == _attribute) {
			AttributeSpecification();
		} else if (la->kind == _disconnect) {
			DisconnectionSpecification();
		} else if (la->kind == _use) {
			UseClause();
		} else if (isGroupTemplate()) {
			GroupTemplateDeclaration();
		} else if (la->kind == _group) {
			GroupDeclaration();
		} else SynErr(149);
}

void Parser::SubprogramDeclaration() {
		SubprogramSpecification();
		Expect(_semicolon);
}

void Parser::ComponentDeclaration() {
		Expect(_component);
		Identifier();
		if (la->kind == _is) {
			Get();
		}
		if (la->kind == _generic) {
			GenericClause();
		}
		if (la->kind == _port) {
			PortClause();
		}
		Expect(_end);
		Expect(_component);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::PackageBodyDeclarativeItem() {
		while (!(StartOf(19))) {SynErr(150); Get();}
		if (StartOf(9)) {
			SubprogramDeclarationOrBody();
		} else if (la->kind == _type) {
			TypeDeclaration();
		} else if (la->kind == _subtype) {
			SubtypeDeclaration();
		} else if (la->kind == _constant) {
			ConstantDeclaration();
		} else if (la->kind == _signal) {
			SignalDeclaration();
		} else if (la->kind == _shared || la->kind == _variable) {
			VariableDeclaration();
		} else if (la->kind == _file) {
			FileDeclaration();
		} else if (la->kind == _alias) {
			AliasDeclaration();
		} else if (la->kind == _use) {
			UseClause();
		} else if (isGroupTemplate()) {
			GroupTemplateDeclaration();
		} else if (la->kind == _group) {
			GroupDeclaration();
		} else SynErr(151);
}

void Parser::Designator() {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		} else if (la->kind == _stringLiteral) {
			Get();
		} else SynErr(152);
}

void Parser::SubprogramSpecification() {
		if (la->kind == _procedure) {
			Get();
			Designator();
			if (la->kind == _lparen) {
				Get();
				ParameterInterfaceListProcedure();
				Expect(_rparen);
			}
		} else if (la->kind == _function || la->kind == _impure || la->kind == _pure) {
			if (la->kind == _impure || la->kind == _pure) {
				if (la->kind == _pure) {
					Get();
				} else {
					Get();
				}
			}
			Expect(_function);
			Designator();
			if (la->kind == _lparen) {
				Get();
				ParameterInterfaceListFunction();
				Expect(_rparen);
			}
			Expect(_return);
			TypeMark();
		} else SynErr(153);
}

void Parser::ParameterInterfaceListProcedure() {
		InterfaceElementProcedure();
		while (la->kind == _semicolon) {
			Get();
			InterfaceElementProcedure();
		}
}

void Parser::ParameterInterfaceListFunction() {
		InterfaceElementFunction();
		while (la->kind == _semicolon) {
			Get();
			InterfaceElementFunction();
		}
}

void Parser::TypeMark() {
		SelectedName();
}

void Parser::SubprogramBody() {
		Expect(_is);
		while (StartOf(11)) {
			SubprogramDeclarativeItem();
		}
		Expect(_begin);
		SequentialStatementList();
		Expect(_end);
		if (la->kind == _function || la->kind == _procedure) {
			if (la->kind == _procedure) {
				Get();
			} else {
				Get();
			}
		}
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			Designator();
		}
}

void Parser::SubprogramDeclarativeItem() {
		while (!(StartOf(20))) {SynErr(154); Get();}
		if (StartOf(9)) {
			SubprogramDeclarationOrBody();
		} else if (la->kind == _type) {
			TypeDeclaration();
		} else if (la->kind == _subtype) {
			SubtypeDeclaration();
		} else if (la->kind == _constant) {
			ConstantDeclaration();
		} else if (la->kind == _shared || la->kind == _variable) {
			VariableDeclaration();
		} else if (la->kind == _file) {
			FileDeclaration();
		} else if (la->kind == _alias) {
			AliasDeclaration();
		} else if (isAttributeDeclaration()) {
			AttributeDeclaration();
		} else if (la->kind == _attribute) {
			AttributeSpecification();
		} else if (la->kind == _use) {
			UseClause();
		} else if (isGroupTemplate()) {
			GroupTemplateDeclaration();
		} else if (la->kind == _group) {
			GroupDeclaration();
		} else SynErr(155);
}

void Parser::SequentialStatementList() {
		while (StartOf(21)) {
			SequentialStatement();
		}
}

void Parser::TypeDefinition() {
		if (la->kind == _lparen) {
			EnumerationTypeDefinition();
		} else if (isPhysicalType()) {
			PhysicalTypeDefinition();
		} else if (la->kind == _range) {
			IntegerOrFloatingPointTypeDefinition();
		} else if (la->kind == _array) {
			ArrayTypeDefinition();
		} else if (la->kind == _record) {
			RecordTypeDefinition();
		} else if (la->kind == _access) {
			AccessTypeDefinition();
		} else if (la->kind == _file) {
			FileTypeDefinition();
		} else if (la->kind==_protected && scanner->Peek()->kind==_body) {
			ProtectedTypeBody();
		} else if (la->kind == _protected) {
			ProtectedTypeDeclaration();
		} else SynErr(156);
}

void Parser::EnumerationTypeDefinition() {
		Expect(_lparen);
		EnumerationLiteral();
		while (la->kind == _comma) {
			Get();
			EnumerationLiteral();
		}
		Expect(_rparen);
}

void Parser::PhysicalTypeDefinition() {
		Expect(_range);
		Range();
		Expect(_units);
		Identifier();
		Expect(_semicolon);
		while (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
			Expect(_eq);
			PhysicalLiteral();
			Expect(_semicolon);
		}
		Expect(_end);
		Expect(_units);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
}

void Parser::IntegerOrFloatingPointTypeDefinition() {
		Expect(_range);
		Range();
}

void Parser::ArrayTypeDefinition() {
		Expect(_array);
		if (isIndexSubtypeDefinition()) {
			Expect(_lparen);
			IndexSubtypeDefinition();
			while (la->kind == _comma) {
				Get();
				IndexSubtypeDefinition();
			}
			Expect(_rparen);
			Expect(_of);
			SubtypeIndication();
		} else if (la->kind == _lparen) {
			IndexConstraint();
			Expect(_of);
			SubtypeIndication();
		} else SynErr(157);
}

void Parser::RecordTypeDefinition() {
		Expect(_record);
		IdentifierList();
		Expect(_colon);
		SubtypeIndication();
		Expect(_semicolon);
		while (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			IdentifierList();
			Expect(_colon);
			SubtypeIndication();
			Expect(_semicolon);
		}
		Expect(_end);
		Expect(_record);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
}

void Parser::AccessTypeDefinition() {
		Expect(_access);
		SubtypeIndication();
}

void Parser::FileTypeDefinition() {
		Expect(_file);
		Expect(_of);
		TypeMark();
}

void Parser::ProtectedTypeBody() {
		Expect(_protected);
		Expect(_body);
		while (StartOf(11)) {
			ProtectedTypeBodyDeclarativeItem();
		}
		Expect(_end);
		Expect(_protected);
		Expect(_body);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
}

void Parser::ProtectedTypeDeclaration() {
		Expect(_protected);
		while (StartOf(22)) {
			ProtectedTypeDeclarativeItem();
		}
		Expect(_end);
		Expect(_protected);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
}

void Parser::IdentifierList() {
		Identifier();
		while (la->kind == _comma) {
			Get();
			Identifier();
		}
}

void Parser::SubtypeIndication() {
		SelectedName();
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			SelectedName();
		}
		if (la->kind == _range || la->kind == _lparen) {
			Constraint();
		}
}

void Parser::AliasDesignator() {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		} else if (la->kind == _characterLiteral) {
			Get();
		} else if (la->kind == _stringLiteral) {
			Get();
		} else SynErr(158);
}

void Parser::Name() {
		Prefix();
		while (StartOf(23)) {
			NamePart();
		}
}

void Parser::Signature() {
		Expect(_lbracket);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			SelectedNameList();
		}
		if (la->kind == _return) {
			Get();
			TypeMark();
		}
		Expect(_rbracket);
}

void Parser::EntityNameList() {
		if (StartOf(24)) {
			EntityDesignator();
			while (la->kind == _comma) {
				Get();
				EntityDesignator();
			}
		} else if (la->kind == _others) {
			Get();
		} else if (la->kind == _all) {
			Get();
		} else SynErr(159);
}

void Parser::EntityClass() {
		switch (la->kind) {
		case _entity: {
			Get();
			break;
		}
		case _architecture: {
			Get();
			break;
		}
		case _configuration: {
			Get();
			break;
		}
		case _package: {
			Get();
			break;
		}
		case _procedure: {
			Get();
			break;
		}
		case _function: {
			Get();
			break;
		}
		case _type: {
			Get();
			break;
		}
		case _subtype: {
			Get();
			break;
		}
		case _constant: {
			Get();
			break;
		}
		case _signal: {
			Get();
			break;
		}
		case _variable: {
			Get();
			break;
		}
		case _file: {
			Get();
			break;
		}
		case _component: {
			Get();
			break;
		}
		case _label: {
			Get();
			break;
		}
		case _literal: {
			Get();
			break;
		}
		case _units: {
			Get();
			break;
		}
		case _group: {
			Get();
			break;
		}
		default: SynErr(160); break;
		}
}

void Parser::EntityDesignator() {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		} else if (la->kind == _characterLiteral) {
			Get();
		} else if (la->kind == _stringLiteral) {
			Get();
		} else SynErr(161);
		if (la->kind == _lbracket) {
			Signature();
		}
}

void Parser::ConfigurationSpecification() {
		Expect(_for);
		ComponentSpecification();
		BindingIndication();
		Expect(_semicolon);
}

void Parser::InstantiationList() {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			IdentifierList();
		} else if (la->kind == _others) {
			Get();
		} else if (la->kind == _all) {
			Get();
		} else SynErr(162);
}

void Parser::EntityAspect() {
		if (la->kind == _entity) {
			Get();
			SelectedName();
			if (la->kind == _lparen) {
				Get();
				Identifier();
				Expect(_rparen);
			}
		} else if (la->kind == _configuration) {
			Get();
			SelectedName();
		} else if (la->kind == _open) {
			Get();
		} else SynErr(163);
}

void Parser::GenericMapAspect() {
		Expect(_generic);
		Expect(_map);
		Expect(_lparen);
		AssociationList();
		Expect(_rparen);
}

void Parser::PortMapAspect() {
		Expect(_port);
		Expect(_map);
		Expect(_lparen);
		AssociationList();
		Expect(_rparen);
}

void Parser::SelectedNameList() {
		SelectedName();
		while (la->kind == _comma) {
			Get();
			SelectedName();
		}
}

void Parser::EntityClassEntry() {
		EntityClass();
		if (la->kind == _box) {
			Get();
		}
}

void Parser::GroupConstituentList() {
		GroupConstituent();
		while (la->kind == _comma) {
			Get();
			GroupConstituent();
		}
}

void Parser::GroupConstituent() {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			Name();
		} else if (la->kind == _characterLiteral) {
			Get();
		} else SynErr(164);
}

void Parser::NamedSelectedNameList(StrList & l) {
		std::string name;
		NamedSelectedName(name);
		l.push_back(name); 
		while (la->kind == _comma) {
			Get();
			NamedSelectedName(name);
			l.push_back(name); 
		}
}

void Parser::EnumerationLiteral() {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		} else if (la->kind == _characterLiteral) {
			Get();
		} else SynErr(165);
}

void Parser::Range() {
		if (isNotNameInRange()) {
			SimpleExpression();
			Direction();
			SimpleExpression();
		} else if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			Name();
		} else SynErr(166);
}

void Parser::PhysicalLiteral() {
		if (la->kind == _integerLiteral) {
			Get();
		} else if (la->kind == _realLiteral) {
			Get();
		} else SynErr(167);
		Identifier();
}

void Parser::IndexSubtypeDefinition() {
		TypeMark();
		Expect(_range);
		Expect(_box);
}

void Parser::IndexConstraint() {
		Expect(_lparen);
		DiscreteRange();
		while (la->kind == _comma) {
			Get();
			DiscreteRange();
		}
		Expect(_rparen);
}

void Parser::ProtectedTypeDeclarativeItem() {
		while (!(StartOf(25))) {SynErr(168); Get();}
		if (StartOf(9)) {
			SubprogramDeclaration();
		} else if (la->kind == _attribute) {
			AttributeSpecification();
		} else if (la->kind == _use) {
			UseClause();
		} else SynErr(169);
}

void Parser::ProtectedTypeBodyDeclarativeItem() {
		while (!(StartOf(20))) {SynErr(170); Get();}
		if (StartOf(9)) {
			SubprogramDeclarationOrBody();
		} else if (la->kind == _type) {
			TypeDeclaration();
		} else if (la->kind == _subtype) {
			SubtypeDeclaration();
		} else if (la->kind == _constant) {
			ConstantDeclaration();
		} else if (la->kind == _shared || la->kind == _variable) {
			VariableDeclaration();
		} else if (la->kind == _file) {
			FileDeclaration();
		} else if (la->kind == _alias) {
			AliasDeclaration();
		} else if (isAttributeDeclaration()) {
			AttributeDeclaration();
		} else if (la->kind == _attribute) {
			AttributeSpecification();
		} else if (la->kind == _use) {
			UseClause();
		} else if (isGroupTemplate()) {
			GroupTemplateDeclaration();
		} else if (la->kind == _group) {
			GroupDeclaration();
		} else SynErr(171);
}

void Parser::Constraint() {
		if (la->kind == _range) {
			RangeConstraint();
		} else if (la->kind == _lparen) {
			IndexConstraint();
		} else SynErr(172);
}

void Parser::Direction() {
		if (la->kind == _to) {
			Get();
		} else if (la->kind == _downto) {
			Get();
		} else SynErr(173);
}

void Parser::RangeConstraint() {
		Expect(_range);
		Range();
}

void Parser::SimpleExpression() {
		if (la->kind == _plus || la->kind == _minus) {
			Sign();
		}
		Term();
		while (la->kind == _ampersand || la->kind == _plus || la->kind == _minus) {
			AddingOperator();
			Term();
		}
}

void Parser::ArchitectureStatement() {
		if (scanner->Peek()->kind==_colon) {
			LabelColon();
			if (isArchitectureStatementWithLabel()) {
				ArchitectureStatementWithLabel();
			} else if (StartOf(13)) {
				ArchitectureStatementOptionalLabel();
			} else SynErr(174);
		} else if (StartOf(13)) {
			ArchitectureStatementOptionalLabel();
		} else SynErr(175);
}

void Parser::ArchitectureStatementWithLabel() {
		if (StartOf(26)) {
			ComponentInstantiationStatement();
		} else if (la->kind == _block) {
			BlockStatement();
		} else if (la->kind == _for || la->kind == _if) {
			GenerateStatement();
		} else SynErr(176);
}

void Parser::ArchitectureStatementOptionalLabel() {
		if (la->kind == _postponed) {
			Get();
		}
		if (la->kind == _process) {
			ProcessStatement();
		} else if (la->kind == _assert) {
			ConcurrentAssertionStatement();
		} else if (isConcurrentSignalAssignmentStatement()) {
			ConcurrentSignalAssignmentStatement();
		} else if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			ConcurrentProcedureCallStatement();
		} else SynErr(177);
}

void Parser::ComponentInstantiationStatement() {
		std::string ent, arch; 
		if (StartOf(27)) {
			if (la->kind == _component) {
				Get();
			}
			SelectedName();
		} else if (la->kind == _entity) {
			Get();
			NamedSelectedName(ent);
			if (la->kind == _lparen) {
				Get();
				NamedIdentifier(arch);
				Expect(_rparen);
			}
			mpDf->AddInstantiation(ent, arch); 
		} else if (la->kind == _configuration) {
			Get();
			SelectedName();
		} else SynErr(178);
		if (la->kind == _generic) {
			GenericMapAspect();
		}
		if (la->kind == _port) {
			PortMapAspect();
		}
		Expect(_semicolon);
}

void Parser::BlockStatement() {
		Expect(_block);
		if (la->kind == _lparen) {
			Get();
			Expression();
			Expect(_rparen);
		}
		if (la->kind == _is) {
			Get();
		}
		if (la->kind == _generic) {
			GenericClause();
			if (la->kind == _generic) {
				GenericMapAspect();
				Expect(_semicolon);
			}
		}
		if (la->kind == _port) {
			PortClause();
			if (la->kind == _port) {
				PortMapAspect();
				Expect(_semicolon);
			}
		}
		while (StartOf(4)) {
			BlockDeclarativeItem();
		}
		Expect(_begin);
		ArchitectureStatementList();
		Expect(_end);
		Expect(_block);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::GenerateStatement() {
		if (la->kind == _for) {
			ForGenerateStatement();
		} else if (la->kind == _if) {
			IfGenerateStatement();
		} else SynErr(179);
}

void Parser::ConcurrentSignalAssignmentStatement() {
		if (StartOf(28)) {
			ConditionalSignalAssignment();
		} else if (la->kind == _with) {
			SelectedSignalAssignment();
		} else SynErr(180);
}

void Parser::AssociationList() {
		AssociationElement();
		while (la->kind == _comma) {
			Get();
			AssociationElement();
		}
}

void Parser::NameList() {
		Name();
		while (la->kind == _comma) {
			Get();
			Name();
		}
}

void Parser::ProcessDeclarativeItem() {
		while (!(StartOf(20))) {SynErr(181); Get();}
		if (StartOf(9)) {
			SubprogramDeclarationOrBody();
		} else if (la->kind == _type) {
			TypeDeclaration();
		} else if (la->kind == _subtype) {
			SubtypeDeclaration();
		} else if (la->kind == _constant) {
			ConstantDeclaration();
		} else if (la->kind == _shared || la->kind == _variable) {
			VariableDeclaration();
		} else if (la->kind == _file) {
			FileDeclaration();
		} else if (la->kind == _alias) {
			AliasDeclaration();
		} else if (la->kind == _use) {
			UseClause();
		} else if (isAttributeDeclaration()) {
			AttributeDeclaration();
		} else if (la->kind == _attribute) {
			AttributeSpecification();
		} else if (isGroupTemplate()) {
			GroupTemplateDeclaration();
		} else if (la->kind == _group) {
			GroupDeclaration();
		} else SynErr(182);
}

void Parser::Condition() {
		Expression();
}

void Parser::ConditionalSignalAssignment() {
		Target();
		Expect(_leq);
		if (la->kind == _guarded) {
			Get();
		}
		if (la->kind == _inertial || la->kind == _reject || la->kind == _transport) {
			DelayMechanism();
		}
		ConditionalWaveforms();
		Expect(_semicolon);
}

void Parser::SelectedSignalAssignment() {
		Expect(_with);
		Expression();
		Expect(_select);
		Target();
		Expect(_leq);
		if (la->kind == _guarded) {
			Get();
		}
		if (la->kind == _inertial || la->kind == _reject || la->kind == _transport) {
			DelayMechanism();
		}
		SelectedWaveform();
		while (la->kind == _comma) {
			Get();
			SelectedWaveform();
		}
		Expect(_semicolon);
}

void Parser::Target() {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			Name();
		} else if (la->kind == _lparen) {
			Aggregate();
		} else SynErr(183);
}

void Parser::DelayMechanism() {
		if (la->kind == _transport) {
			Get();
		} else if (la->kind == _inertial || la->kind == _reject) {
			if (la->kind == _reject) {
				Get();
				Expression();
			}
			Expect(_inertial);
		} else SynErr(184);
}

void Parser::ConditionalWaveforms() {
		Waveform();
		if (la->kind == _when) {
			Get();
			Condition();
			if (la->kind == _else) {
				Get();
				ConditionalWaveforms();
			}
		}
}

void Parser::Waveform() {
		if (StartOf(15)) {
			WaveformElement();
			while (la->kind == _comma) {
				Get();
				WaveformElement();
			}
		} else if (la->kind == _unaffected) {
			Get();
		} else SynErr(185);
}

void Parser::SelectedWaveform() {
		Waveform();
		Expect(_when);
		Choices();
}

void Parser::Choices() {
		Choice();
		while (la->kind == _bar) {
			Get();
			Choice();
		}
}

void Parser::Aggregate() {
		Expect(_lparen);
		ElementAssociation();
		while (la->kind == _comma) {
			Get();
			ElementAssociation();
		}
		Expect(_rparen);
}

void Parser::ForGenerateStatement() {
		Expect(_for);
		Identifier();
		Expect(_in);
		DiscreteRange();
		Expect(_generate);
		GenerateStatementBody();
		Expect(_end);
		Expect(_generate);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::IfGenerateStatement() {
		Expect(_if);
		Condition();
		Expect(_generate);
		GenerateStatementBody();
		Expect(_end);
		Expect(_generate);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::GenerateStatementBody() {
		if (StartOf(29)) {
			while (StartOf(4)) {
				BlockDeclarativeItem();
			}
			Expect(_begin);
		}
		ArchitectureStatementList();
}

void Parser::SequentialStatement() {
		if (scanner->Peek()->kind==_colon) {
			LabelColon();
		}
		while (!(StartOf(30))) {SynErr(186); Get();}
		if (la->kind == _wait) {
			WaitStatement();
		} else if (la->kind == _assert) {
			AssertionStatement();
		} else if (la->kind == _report) {
			ReportStatement();
		} else if (la->kind == _if) {
			IfStatement();
		} else if (la->kind == _case) {
			CaseStatement();
		} else if (la->kind == _for || la->kind == _loop || la->kind == _while) {
			LoopStatement();
		} else if (la->kind == _next) {
			NextStatement();
		} else if (la->kind == _exit) {
			ExitStatement();
		} else if (la->kind == _return) {
			ReturnStatement();
		} else if (la->kind == _null) {
			NullStatement();
		} else if (isAssignmentStatement()) {
			SignalOrVariableAssignmentStatement();
		} else if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			ProcedureCallStatement();
		} else SynErr(187);
}

void Parser::WaitStatement() {
		Expect(_wait);
		if (la->kind == _on) {
			Get();
			NameList();
		}
		if (la->kind == _until) {
			Get();
			Condition();
		}
		if (la->kind == _for) {
			Get();
			Expression();
		}
		Expect(_semicolon);
}

void Parser::AssertionStatement() {
		Expect(_assert);
		Condition();
		if (la->kind == _report) {
			Get();
			Expression();
		}
		if (la->kind == _severity) {
			Get();
			Expression();
		}
		Expect(_semicolon);
}

void Parser::ReportStatement() {
		Expect(_report);
		Expression();
		if (la->kind == _severity) {
			Get();
			Expression();
		}
		Expect(_semicolon);
}

void Parser::IfStatement() {
		Expect(_if);
		Condition();
		Expect(_then);
		SequentialStatementList();
		while (la->kind == _elsif) {
			Get();
			Condition();
			Expect(_then);
			SequentialStatementList();
		}
		if (la->kind == _else) {
			Get();
			SequentialStatementList();
		}
		Expect(_end);
		Expect(_if);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::CaseStatement() {
		Expect(_case);
		Expression();
		Expect(_is);
		Expect(_when);
		Choices();
		Expect(_arrow);
		SequentialStatementList();
		while (la->kind == _when) {
			Get();
			Choices();
			Expect(_arrow);
			SequentialStatementList();
		}
		Expect(_end);
		Expect(_case);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::LoopStatement() {
		if (la->kind == _for || la->kind == _while) {
			IterationScheme();
		}
		Expect(_loop);
		SequentialStatementList();
		Expect(_end);
		Expect(_loop);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		Expect(_semicolon);
}

void Parser::NextStatement() {
		Expect(_next);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		if (la->kind == _when) {
			Get();
			Condition();
		}
		Expect(_semicolon);
}

void Parser::ExitStatement() {
		Expect(_exit);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		}
		if (la->kind == _when) {
			Get();
			Condition();
		}
		Expect(_semicolon);
}

void Parser::ReturnStatement() {
		Expect(_return);
		if (StartOf(15)) {
			Expression();
		}
		Expect(_semicolon);
}

void Parser::NullStatement() {
		Expect(_null);
		Expect(_semicolon);
}

void Parser::SignalOrVariableAssignmentStatement() {
		Target();
		if (la->kind == _leq) {
			SignalAssignmentStatement();
		} else if (la->kind == _varAssign) {
			VariableAssignmentStatement();
		} else SynErr(188);
}

void Parser::ProcedureCallStatement() {
		SelectedName();
		if (la->kind == _lparen) {
			Get();
			AssociationList();
			Expect(_rparen);
		}
		Expect(_semicolon);
}

void Parser::SignalAssignmentStatement() {
		Expect(_leq);
		if (la->kind == _inertial || la->kind == _reject || la->kind == _transport) {
			DelayMechanism();
		}
		Waveform();
		Expect(_semicolon);
}

void Parser::VariableAssignmentStatement() {
		Expect(_varAssign);
		Expression();
		Expect(_semicolon);
}

void Parser::WaveformElement() {
		Expression();
		if (la->kind == _after) {
			Get();
			Expression();
		}
}

void Parser::IterationScheme() {
		if (la->kind == _while) {
			Get();
			Condition();
		} else if (la->kind == _for) {
			Get();
			Identifier();
			Expect(_in);
			DiscreteRange();
		} else SynErr(189);
}

void Parser::InterfaceElementProcedure() {
		if (isInterfaceConstantDeclaration()) {
			InterfaceConstantDeclaration();
		} else if (isInterfaceVariableDeclaration()) {
			InterfaceVariableDeclaration();
		} else if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _signal) {
			InterfaceSignalDeclarationProcedure();
		} else if (la->kind == _file) {
			InterfaceFileDeclaration();
		} else SynErr(190);
}

void Parser::InterfaceVariableDeclaration() {
		if (la->kind == _variable) {
			Get();
		}
		IdentifierList();
		Expect(_colon);
		if (StartOf(7)) {
			InterfaceMode();
		}
		SubtypeIndication();
		if (la->kind == _varAssign) {
			Get();
			Expression();
		}
}

void Parser::InterfaceFileDeclaration() {
		Expect(_file);
		IdentifierList();
		Expect(_colon);
		SubtypeIndication();
}

void Parser::InterfaceElementFunction() {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _constant) {
			InterfaceConstantDeclaration();
		} else if (la->kind == _signal) {
			InterfaceSignalDeclarationFunction();
		} else if (la->kind == _file) {
			InterfaceFileDeclaration();
		} else SynErr(191);
}

void Parser::InterfaceSignalDeclarationFunction() {
		Expect(_signal);
		IdentifierList();
		Expect(_colon);
		if (la->kind == _in) {
			Get();
		}
		SubtypeIndication();
		if (la->kind == _bus) {
			Get();
		}
		if (la->kind == _varAssign) {
			Get();
			Expression();
		}
}

void Parser::InterfaceMode() {
		if (la->kind == _in) {
			Get();
		} else if (la->kind == _outToken) {
			Get();
		} else if (la->kind == _inout) {
			Get();
		} else if (la->kind == _buffer) {
			Get();
		} else if (la->kind == _linkage) {
			Get();
		} else SynErr(192);
}

void Parser::AssociationElement() {
		if (isFormalPartInAssociationElement()) {
			FormalPart();
			Expect(_arrow);
		}
		ActualPart();
}

void Parser::FormalPart() {
		Name();
}

void Parser::ActualPart() {
		if (StartOf(15)) {
			Expression();
		} else if (la->kind == _open) {
			Get();
		} else SynErr(193);
}

void Parser::Relation() {
		ShiftExpression();
		if (StartOf(31)) {
			RelationalOperator();
			ShiftExpression();
		}
}

void Parser::LogicalOperator() {
		switch (la->kind) {
		case _and: {
			Get();
			break;
		}
		case _or: {
			Get();
			break;
		}
		case _xor: {
			Get();
			break;
		}
		case _xnor: {
			Get();
			break;
		}
		case _nand: {
			Get();
			break;
		}
		case _nor: {
			Get();
			break;
		}
		default: SynErr(194); break;
		}
}

void Parser::ShiftExpression() {
		SimpleExpression();
		if (StartOf(32)) {
			ShiftOperator();
			SimpleExpression();
		}
}

void Parser::RelationalOperator() {
		switch (la->kind) {
		case _eq: {
			Get();
			break;
		}
		case _neq: {
			Get();
			break;
		}
		case _lt: {
			Get();
			break;
		}
		case _leq: {
			Get();
			break;
		}
		case _gt: {
			Get();
			break;
		}
		case _geq: {
			Get();
			break;
		}
		default: SynErr(195); break;
		}
}

void Parser::ShiftOperator() {
		switch (la->kind) {
		case _sll: {
			Get();
			break;
		}
		case _srl: {
			Get();
			break;
		}
		case _sla: {
			Get();
			break;
		}
		case _sra: {
			Get();
			break;
		}
		case _rol: {
			Get();
			break;
		}
		case _ror: {
			Get();
			break;
		}
		default: SynErr(196); break;
		}
}

void Parser::Sign() {
		if (la->kind == _plus) {
			Get();
		} else if (la->kind == _minus) {
			Get();
		} else SynErr(197);
}

void Parser::Term() {
		Factor();
		while (StartOf(33)) {
			MultiplyingOperator();
			Factor();
		}
}

void Parser::AddingOperator() {
		if (la->kind == _plus) {
			Get();
		} else if (la->kind == _minus) {
			Get();
		} else if (la->kind == _ampersand) {
			Get();
		} else SynErr(198);
}

void Parser::MultiplyingOperator() {
		if (la->kind == _mul) {
			Get();
		} else if (la->kind == _div) {
			Get();
		} else if (la->kind == _mod) {
			Get();
		} else if (la->kind == _rem) {
			Get();
		} else SynErr(199);
}

void Parser::Factor() {
		if (StartOf(34)) {
			Primary();
			if (la->kind == _doublestar) {
				Get();
				Primary();
			}
		} else if (la->kind == _abs) {
			Get();
			Primary();
		} else if (la->kind == _not) {
			Get();
			Primary();
		} else SynErr(200);
}

void Parser::Primary() {
		if (isQualifiedExpression()) {
			SelectedName();
			QualifiedExpression();
		} else if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier || la->kind == _stringLiteral) {
			Name();
		} else if (StartOf(35)) {
			Literal();
		} else if (la->kind == _new) {
			Allocator();
		} else if (la->kind == _lparen) {
			Aggregate();
		} else SynErr(201);
}

void Parser::QualifiedExpression() {
		Expect(_apostrophe);
		Aggregate();
}

void Parser::Literal() {
		switch (la->kind) {
		case _realLiteral: {
			Get();
			break;
		}
		case _integerLiteral: {
			Get();
			break;
		}
		case _basedLiteral: {
			Get();
			break;
		}
		case _characterLiteral: {
			Get();
			break;
		}
		case _bitStringLiteral: {
			Get();
			break;
		}
		case _null: {
			Get();
			break;
		}
		default: SynErr(202); break;
		}
		if ((t->kind==_integerLiteral || t->kind==_realLiteral) && (la->kind==_basicIdentifier || la->kind==_extendedIdentifier)) {
			Identifier();
		}
}

void Parser::Allocator() {
		Expect(_new);
		SelectedName();
		if (la->kind == _apostrophe) {
			QualifiedExpression();
		} else if (StartOf(36)) {
			if (la->kind == _lparen) {
				IndexConstraint();
			}
		} else SynErr(203);
}

void Parser::Prefix() {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		} else if (la->kind == _stringLiteral) {
			Get();
		} else SynErr(204);
}

void Parser::SelectedPart() {
		Expect(_dot);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		} else if (la->kind == _characterLiteral) {
			Get();
		} else if (la->kind == _stringLiteral) {
			Get();
		} else if (la->kind == _all) {
			Get();
		} else SynErr(205);
}

void Parser::NamedPrefix(std::string & s) {
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			NamedIdentifier(s);
		} else if (la->kind == _stringLiteral) {
			Get();
			s = CurrentToken(); 
		} else SynErr(206);
}

void Parser::NamedSelectedPart(std::string & n) {
		n = "."; std::string s; 
		Expect(_dot);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			NamedIdentifier(s);
			n += s; 
		} else if (la->kind == _characterLiteral) {
			Get();
			n += CurrentToken(); 
		} else if (la->kind == _stringLiteral) {
			Get();
			n += CurrentToken(); 
		} else if (la->kind == _all) {
			Get();
			n += CurrentToken(); 
		} else SynErr(207);
}

void Parser::NamePart() {
		if (la->kind == _dot) {
			SelectedPart();
		} else if (la->kind == _apostrophe || la->kind == _lbracket) {
			AttributePart();
		} else if (isSlicePart()) {
			SlicePart();
		} else if (la->kind == _lparen) {
			AssociationListPart();
		} else SynErr(208);
}

void Parser::AttributePart() {
		if (la->kind == _lbracket) {
			Signature();
		}
		Expect(_apostrophe);
		if (la->kind == _basicIdentifier || la->kind == _extendedIdentifier) {
			Identifier();
		} else if (la->kind == _range) {
			Get();
		} else SynErr(209);
		if (la->kind == _lparen) {
			Get();
			Expression();
			Expect(_rparen);
		}
}

void Parser::SlicePart() {
		Expect(_lparen);
		DiscreteRange();
		Expect(_rparen);
}

void Parser::AssociationListPart() {
		Expect(_lparen);
		AssociationList();
		Expect(_rparen);
}

void Parser::ElementAssociation() {
		if (isChoiceInElementAssociation()) {
			Choices();
			Expect(_arrow);
		}
		Expression();
}

void Parser::Choice() {
		if (isRangeInChoice()) {
			DiscreteRange();
		} else if (StartOf(15)) {
			SimpleExpression();
		} else if (la->kind == _others) {
			Get();
		} else SynErr(210);
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	t = NULL;
	la = dummyToken = new Token();
	la->val = coco_string_create(L"Dummy Token");
	Get();
	VHDL();
	Expect(0);
}

Parser::Parser(Scanner *scanner) {
	maxT = 132;

	ParserInitCaller<Parser>::CallInit(this);
	dummyToken = NULL;
	t = la = NULL;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = new Errors();
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[37][134] = {
		{T,T,T,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,T,T, x,x,x,x, x,T,T,x, T,T,x,x, x,x,x,T, T,T,T,x, x,T,x,T, T,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, T,T,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,T,x, T,T,x,x, x,x,x,x, T,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,T,x, T,T,x,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,T,T,x, x,x,T,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,T,x, T,T,x,x, x,x,x,x, T,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,T,T,T, T,T,T,T, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,T,x, T,T,x,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, T,x,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,T, x,x},
		{x,T,T,x, x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,T, T,x,x,x, x,x,T,x, T,T,x,x, x,x,x,x, T,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,x,x,x, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{T,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x},
		{x,T,T,T, T,T,T,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,T, T,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,T, x,x,x,x, x,T,x,T, x,x,x,x, x,x,T,x, T,x,x,x, x,T,x,T, T,x,x,T, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,T,x,T, T,x,T,T, T,T,x,x, T,T,T,T, x,T,T,x, x,x,T,x, x,x,x,T, x,x,T,T, T,T,T,T, T,T,x,T, T,T,T,T, x,x,x,T, T,T,T,T, T,T,T,x, x,x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
	delete errors;
	delete dummyToken;
}

Errors::Errors() {
	count = 0;
}

void Errors::SynErr(int line, int col, int n) {
	wchar_t* s;
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"basicIdentifier expected"); break;
			case 2: s = coco_string_create(L"extendedIdentifier expected"); break;
			case 3: s = coco_string_create(L"basedLiteral expected"); break;
			case 4: s = coco_string_create(L"integerLiteral expected"); break;
			case 5: s = coco_string_create(L"realLiteral expected"); break;
			case 6: s = coco_string_create(L"stringLiteral expected"); break;
			case 7: s = coco_string_create(L"bitStringLiteral expected"); break;
			case 8: s = coco_string_create(L"apostrophe expected"); break;
			case 9: s = coco_string_create(L"characterLiteral expected"); break;
			case 10: s = coco_string_create(L"abs expected"); break;
			case 11: s = coco_string_create(L"access expected"); break;
			case 12: s = coco_string_create(L"after expected"); break;
			case 13: s = coco_string_create(L"alias expected"); break;
			case 14: s = coco_string_create(L"all expected"); break;
			case 15: s = coco_string_create(L"and expected"); break;
			case 16: s = coco_string_create(L"architecture expected"); break;
			case 17: s = coco_string_create(L"array expected"); break;
			case 18: s = coco_string_create(L"assert expected"); break;
			case 19: s = coco_string_create(L"attribute expected"); break;
			case 20: s = coco_string_create(L"begin expected"); break;
			case 21: s = coco_string_create(L"block expected"); break;
			case 22: s = coco_string_create(L"body expected"); break;
			case 23: s = coco_string_create(L"buffer expected"); break;
			case 24: s = coco_string_create(L"bus expected"); break;
			case 25: s = coco_string_create(L"case expected"); break;
			case 26: s = coco_string_create(L"component expected"); break;
			case 27: s = coco_string_create(L"configuration expected"); break;
			case 28: s = coco_string_create(L"constant expected"); break;
			case 29: s = coco_string_create(L"disconnect expected"); break;
			case 30: s = coco_string_create(L"downto expected"); break;
			case 31: s = coco_string_create(L"else expected"); break;
			case 32: s = coco_string_create(L"elsif expected"); break;
			case 33: s = coco_string_create(L"end expected"); break;
			case 34: s = coco_string_create(L"entity expected"); break;
			case 35: s = coco_string_create(L"exit expected"); break;
			case 36: s = coco_string_create(L"file expected"); break;
			case 37: s = coco_string_create(L"for expected"); break;
			case 38: s = coco_string_create(L"function expected"); break;
			case 39: s = coco_string_create(L"generate expected"); break;
			case 40: s = coco_string_create(L"generic expected"); break;
			case 41: s = coco_string_create(L"group expected"); break;
			case 42: s = coco_string_create(L"guarded expected"); break;
			case 43: s = coco_string_create(L"if expected"); break;
			case 44: s = coco_string_create(L"impure expected"); break;
			case 45: s = coco_string_create(L"in expected"); break;
			case 46: s = coco_string_create(L"inertial expected"); break;
			case 47: s = coco_string_create(L"inout expected"); break;
			case 48: s = coco_string_create(L"is expected"); break;
			case 49: s = coco_string_create(L"label expected"); break;
			case 50: s = coco_string_create(L"library expected"); break;
			case 51: s = coco_string_create(L"linkage expected"); break;
			case 52: s = coco_string_create(L"literal expected"); break;
			case 53: s = coco_string_create(L"loop expected"); break;
			case 54: s = coco_string_create(L"map expected"); break;
			case 55: s = coco_string_create(L"mod expected"); break;
			case 56: s = coco_string_create(L"nand expected"); break;
			case 57: s = coco_string_create(L"new expected"); break;
			case 58: s = coco_string_create(L"next expected"); break;
			case 59: s = coco_string_create(L"nor expected"); break;
			case 60: s = coco_string_create(L"not expected"); break;
			case 61: s = coco_string_create(L"null expected"); break;
			case 62: s = coco_string_create(L"of expected"); break;
			case 63: s = coco_string_create(L"on expected"); break;
			case 64: s = coco_string_create(L"open expected"); break;
			case 65: s = coco_string_create(L"or expected"); break;
			case 66: s = coco_string_create(L"others expected"); break;
			case 67: s = coco_string_create(L"outToken expected"); break;
			case 68: s = coco_string_create(L"package expected"); break;
			case 69: s = coco_string_create(L"port expected"); break;
			case 70: s = coco_string_create(L"postponed expected"); break;
			case 71: s = coco_string_create(L"procedure expected"); break;
			case 72: s = coco_string_create(L"process expected"); break;
			case 73: s = coco_string_create(L"protected expected"); break;
			case 74: s = coco_string_create(L"pure expected"); break;
			case 75: s = coco_string_create(L"range expected"); break;
			case 76: s = coco_string_create(L"record expected"); break;
			case 77: s = coco_string_create(L"register expected"); break;
			case 78: s = coco_string_create(L"reject expected"); break;
			case 79: s = coco_string_create(L"rem expected"); break;
			case 80: s = coco_string_create(L"report expected"); break;
			case 81: s = coco_string_create(L"return expected"); break;
			case 82: s = coco_string_create(L"rol expected"); break;
			case 83: s = coco_string_create(L"ror expected"); break;
			case 84: s = coco_string_create(L"select expected"); break;
			case 85: s = coco_string_create(L"severity expected"); break;
			case 86: s = coco_string_create(L"shared expected"); break;
			case 87: s = coco_string_create(L"signal expected"); break;
			case 88: s = coco_string_create(L"sla expected"); break;
			case 89: s = coco_string_create(L"sll expected"); break;
			case 90: s = coco_string_create(L"sra expected"); break;
			case 91: s = coco_string_create(L"srl expected"); break;
			case 92: s = coco_string_create(L"subtype expected"); break;
			case 93: s = coco_string_create(L"then expected"); break;
			case 94: s = coco_string_create(L"to expected"); break;
			case 95: s = coco_string_create(L"transport expected"); break;
			case 96: s = coco_string_create(L"type expected"); break;
			case 97: s = coco_string_create(L"unaffected expected"); break;
			case 98: s = coco_string_create(L"units expected"); break;
			case 99: s = coco_string_create(L"until expected"); break;
			case 100: s = coco_string_create(L"use expected"); break;
			case 101: s = coco_string_create(L"variable expected"); break;
			case 102: s = coco_string_create(L"wait expected"); break;
			case 103: s = coco_string_create(L"when expected"); break;
			case 104: s = coco_string_create(L"while expected"); break;
			case 105: s = coco_string_create(L"with expected"); break;
			case 106: s = coco_string_create(L"xnor expected"); break;
			case 107: s = coco_string_create(L"xor expected"); break;
			case 108: s = coco_string_create(L"doublestar expected"); break;
			case 109: s = coco_string_create(L"leq expected"); break;
			case 110: s = coco_string_create(L"geq expected"); break;
			case 111: s = coco_string_create(L"arrow expected"); break;
			case 112: s = coco_string_create(L"neq expected"); break;
			case 113: s = coco_string_create(L"varAssign expected"); break;
			case 114: s = coco_string_create(L"box expected"); break;
			case 115: s = coco_string_create(L"semicolon expected"); break;
			case 116: s = coco_string_create(L"comma expected"); break;
			case 117: s = coco_string_create(L"ampersand expected"); break;
			case 118: s = coco_string_create(L"lparen expected"); break;
			case 119: s = coco_string_create(L"rparen expected"); break;
			case 120: s = coco_string_create(L"lbracket expected"); break;
			case 121: s = coco_string_create(L"rbracket expected"); break;
			case 122: s = coco_string_create(L"colon expected"); break;
			case 123: s = coco_string_create(L"mul expected"); break;
			case 124: s = coco_string_create(L"div expected"); break;
			case 125: s = coco_string_create(L"plus expected"); break;
			case 126: s = coco_string_create(L"minus expected"); break;
			case 127: s = coco_string_create(L"lt expected"); break;
			case 128: s = coco_string_create(L"gt expected"); break;
			case 129: s = coco_string_create(L"eq expected"); break;
			case 130: s = coco_string_create(L"bar expected"); break;
			case 131: s = coco_string_create(L"dot expected"); break;
			case 132: s = coco_string_create(L"??? expected"); break;
			case 133: s = coco_string_create(L"invalid LibraryUnit"); break;
			case 134: s = coco_string_create(L"invalid EntityDeclaration"); break;
			case 135: s = coco_string_create(L"invalid NamedIdentifier"); break;
			case 136: s = coco_string_create(L"this symbol not expected in EntityDeclarativeItem"); break;
			case 137: s = coco_string_create(L"invalid EntityDeclarativeItem"); break;
			case 138: s = coco_string_create(L"invalid Identifier"); break;
			case 139: s = coco_string_create(L"invalid TypeDeclaration"); break;
			case 140: s = coco_string_create(L"invalid DisconnectionSpecification"); break;
			case 141: s = coco_string_create(L"this symbol not expected in BlockDeclarativeItem"); break;
			case 142: s = coco_string_create(L"invalid BlockDeclarativeItem"); break;
			case 143: s = coco_string_create(L"this symbol not expected in ConfigurationDeclarativeItem"); break;
			case 144: s = coco_string_create(L"invalid ConfigurationDeclarativeItem"); break;
			case 145: s = coco_string_create(L"invalid BlockConfigurationIndex"); break;
			case 146: s = coco_string_create(L"invalid DiscreteRange"); break;
			case 147: s = coco_string_create(L"invalid BlockSpecification"); break;
			case 148: s = coco_string_create(L"this symbol not expected in PackageDeclarativeItem"); break;
			case 149: s = coco_string_create(L"invalid PackageDeclarativeItem"); break;
			case 150: s = coco_string_create(L"this symbol not expected in PackageBodyDeclarativeItem"); break;
			case 151: s = coco_string_create(L"invalid PackageBodyDeclarativeItem"); break;
			case 152: s = coco_string_create(L"invalid Designator"); break;
			case 153: s = coco_string_create(L"invalid SubprogramSpecification"); break;
			case 154: s = coco_string_create(L"this symbol not expected in SubprogramDeclarativeItem"); break;
			case 155: s = coco_string_create(L"invalid SubprogramDeclarativeItem"); break;
			case 156: s = coco_string_create(L"invalid TypeDefinition"); break;
			case 157: s = coco_string_create(L"invalid ArrayTypeDefinition"); break;
			case 158: s = coco_string_create(L"invalid AliasDesignator"); break;
			case 159: s = coco_string_create(L"invalid EntityNameList"); break;
			case 160: s = coco_string_create(L"invalid EntityClass"); break;
			case 161: s = coco_string_create(L"invalid EntityDesignator"); break;
			case 162: s = coco_string_create(L"invalid InstantiationList"); break;
			case 163: s = coco_string_create(L"invalid EntityAspect"); break;
			case 164: s = coco_string_create(L"invalid GroupConstituent"); break;
			case 165: s = coco_string_create(L"invalid EnumerationLiteral"); break;
			case 166: s = coco_string_create(L"invalid Range"); break;
			case 167: s = coco_string_create(L"invalid PhysicalLiteral"); break;
			case 168: s = coco_string_create(L"this symbol not expected in ProtectedTypeDeclarativeItem"); break;
			case 169: s = coco_string_create(L"invalid ProtectedTypeDeclarativeItem"); break;
			case 170: s = coco_string_create(L"this symbol not expected in ProtectedTypeBodyDeclarativeItem"); break;
			case 171: s = coco_string_create(L"invalid ProtectedTypeBodyDeclarativeItem"); break;
			case 172: s = coco_string_create(L"invalid Constraint"); break;
			case 173: s = coco_string_create(L"invalid Direction"); break;
			case 174: s = coco_string_create(L"invalid ArchitectureStatement"); break;
			case 175: s = coco_string_create(L"invalid ArchitectureStatement"); break;
			case 176: s = coco_string_create(L"invalid ArchitectureStatementWithLabel"); break;
			case 177: s = coco_string_create(L"invalid ArchitectureStatementOptionalLabel"); break;
			case 178: s = coco_string_create(L"invalid ComponentInstantiationStatement"); break;
			case 179: s = coco_string_create(L"invalid GenerateStatement"); break;
			case 180: s = coco_string_create(L"invalid ConcurrentSignalAssignmentStatement"); break;
			case 181: s = coco_string_create(L"this symbol not expected in ProcessDeclarativeItem"); break;
			case 182: s = coco_string_create(L"invalid ProcessDeclarativeItem"); break;
			case 183: s = coco_string_create(L"invalid Target"); break;
			case 184: s = coco_string_create(L"invalid DelayMechanism"); break;
			case 185: s = coco_string_create(L"invalid Waveform"); break;
			case 186: s = coco_string_create(L"this symbol not expected in SequentialStatement"); break;
			case 187: s = coco_string_create(L"invalid SequentialStatement"); break;
			case 188: s = coco_string_create(L"invalid SignalOrVariableAssignmentStatement"); break;
			case 189: s = coco_string_create(L"invalid IterationScheme"); break;
			case 190: s = coco_string_create(L"invalid InterfaceElementProcedure"); break;
			case 191: s = coco_string_create(L"invalid InterfaceElementFunction"); break;
			case 192: s = coco_string_create(L"invalid InterfaceMode"); break;
			case 193: s = coco_string_create(L"invalid ActualPart"); break;
			case 194: s = coco_string_create(L"invalid LogicalOperator"); break;
			case 195: s = coco_string_create(L"invalid RelationalOperator"); break;
			case 196: s = coco_string_create(L"invalid ShiftOperator"); break;
			case 197: s = coco_string_create(L"invalid Sign"); break;
			case 198: s = coco_string_create(L"invalid AddingOperator"); break;
			case 199: s = coco_string_create(L"invalid MultiplyingOperator"); break;
			case 200: s = coco_string_create(L"invalid Factor"); break;
			case 201: s = coco_string_create(L"invalid Primary"); break;
			case 202: s = coco_string_create(L"invalid Literal"); break;
			case 203: s = coco_string_create(L"invalid Allocator"); break;
			case 204: s = coco_string_create(L"invalid Prefix"); break;
			case 205: s = coco_string_create(L"invalid SelectedPart"); break;
			case 206: s = coco_string_create(L"invalid NamedPrefix"); break;
			case 207: s = coco_string_create(L"invalid NamedSelectedPart"); break;
			case 208: s = coco_string_create(L"invalid NamePart"); break;
			case 209: s = coco_string_create(L"invalid AttributePart"); break;
			case 210: s = coco_string_create(L"invalid Choice"); break;

		default:
		{
			wchar_t format[20];
			coco_swprintf(format, 20, L"error %d", n);
			s = coco_string_create(format);
		}
		break;
	}
	wprintf(L"-- line %d col %d: %ls\n", line, col, s);
	coco_string_delete(s);
	count++;
}

void Errors::Error(int line, int col, const wchar_t *s) {
	wprintf(L"-- line %d col %d: %ls\n", line, col, s);
	count++;
}

void Errors::Warning(int line, int col, const wchar_t *s) {
	wprintf(L"-- line %d col %d: %ls\n", line, col, s);
}

void Errors::Warning(const wchar_t *s) {
	wprintf(L"%ls\n", s);
}

void Errors::Exception(const wchar_t* s) {
	wprintf(L"%ls", s); 
	exit(1);
}

} // namespace

